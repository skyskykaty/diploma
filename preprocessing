# преобразование строки с дефектами

def process_defects(defect_str): -> list
    '''
    # преобразовывает строку с дефектами в список дефектов вида ['XX-YY (комментарий), ...]
    # обрабатывает скобки в скобках
    # возвращает список дефектов
    '''
    defect_str = str(defect_str)

    # Обрпабатываем вложенные скобки
    result = []
    buffer = []
    open_parentheses = 0

    for char in defect_str:
        if char == '(':
            if open_parentheses > 0:
                buffer.append(char)
            open_parentheses += 1
            if open_parentheses == 1:
                buffer.append('(')  # Добавляем первую скобку
        elif char == ')':
            open_parentheses -= 1
            if open_parentheses > 0:
                buffer.append(char)
            elif open_parentheses == 0:
                buffer.append(')')
                result.append(''.join(buffer).strip())
                buffer = []
        elif char == ',' and open_parentheses == 0:
            if buffer:
                result.append(''.join(buffer).strip())
                buffer = []
        else:
            buffer.append(char)

    if buffer:
        result.append(''.join(buffer).strip())

    return result

def extract_cycles_count(defect_list):
    '''
    переносит количество включений в отдельный столбец
    возвращает список дефектов без количества включений, количество включений в отдельном столбце
    '''
    if not isinstance(defect_list, list):
        return pd.Series([None, defect_list])

    cycle_count = None
    cleaned_defects = []

    for d in defect_list:
        d_clean = d.strip()

        # Если элемент начинается с "88" (учтём, что могут быть варианты "88", "88-XX", и т.п.)
        if d_clean.startswith("88"):
            match = re.search(r'\((\d+)\+?\)', d_clean)
            if match:
                cycle_count = int(match.group(1))
                # Не добавляем этот элемент в итоговый список дефектов
                continue

        cleaned_defects.append(d)

    return pd.Series([cycle_count, cleaned_defects])


def remove_99_defects(defects):
    '''
    удаляет дефекты с кодом 99-ХХ
    возвращает список без этих дефектов
    '''
    filtered = []
    for d in defects:
        # Если элемент начинается с "99" (с вариантами "99", "99-XX" и т.д.),
        # игнорируем его
        if d.strip().startswith("99"):
            continue
        filtered.append(d)

    return filtered if filtered else None


# только для обработки исторических данных

def extract_cycle_counts_from_list(defects):
    '''
    обрабатывает количество включений, которое внесено неверно
    возвращает количество включений в отдельном столбце
    '''
    if not isinstance(defects, list):
        return pd.Series([None, defects])

    cycle_count = None
    pattern = r'^\((\d+)\+?\)$'

    if defects and re.match(pattern, defects[0]):
        m = re.match(pattern, defects[0])
        if m:
            cycle_count = int(m.group(1))
        defects = defects[1:]

    return pd.Series([cycle_count, defects])


def remove_noncode_comments(defect_list):
    '''
    удаляет неверно внесенные комментарии
    возвращает список без комментариев
    '''
    # Если defect_list — это None, возвращаем его без изменений
    if defect_list is None:
        return defect_list

    # Регулярное выражение для поиска дефектов в формате XX-XX и комментариев в скобках
    valid_defect_pattern = r'^\d{2}-\d{2}(\s*\(.*\))?$'

    # Фильтруем дефекты, оставляя только те, которые соответствуют формату XX-XX (с комментариями в скобках)
    cleaned_list = [defect.strip() for defect in defect_list
                    if pd.notna(defect) and re.match(valid_defect_pattern, defect.strip())]

    return cleaned_list

def extract_defect_codes(defects):
    '''
    создает список кодов дефектов без комментариев
    '''
    if not defects:
        return []
    return list({re.findall(r'\d{2}-\d{2}', d)[0] for d in defects if re.findall(r'\d{2}-\d{2}', d)})

def replace_defect_codes_with_description(defect_list, df_transl):
    """
    Заменяет коды дефектов вида 'XX-YY' на текст вида 'описание_XX - описание_YY',
    сохраняя комментарий (если есть в скобках).

    Parameters:
        defect_list (list of str): строки вида 'XX-YY (комментарий)'
        df_transl (pd.DataFrame): содержит колонки 'code', 'col1', 'col2'

    Returns:
        list of str: тексты с заменёнными кодами, готовые для векторизации
    """
    if not isinstance(defect_list, list):
        return []

    # Создаём словарь: XX-YY -> "описание XX - описание YY"
    code_to_desc = {}
    for _, row in df_transl.iterrows():
        code = row["code"]
        desc = f"{row['col1']} - {row['col2']}"
        code_to_desc[code] = desc

    result = []
    for defect in defect_list:
        match = re.match(r"(\d{2}-\d{2})(?:\s*\((.*?)\))?", defect)
        if match:
            code = match.group(1)
            comment = match.group(2)
            description = code_to_desc.get(code, code)
            if comment:
                result.append(f"{description} ({comment})")
            else:
                result.append(description)
        else:
            # если код не распознан, оставляем строку как есть
            result.append(defect)

    return result


# преобразование дефектов с использований функций выше

df['defects'] = df['defects'].apply(process_defects)
df[['cycle_counts', 'defects']] = df['defects'].apply(extract_cycles_count)
df['defects'] = df['defects'].apply(remove_99_defects)
df[['cycle_counts', 'defects']] = df.apply(lambda row: extract_cycle_counts_from_list(row['defects']) if pd.isna(row['cycle_counts']) else pd.Series([row['cycle_counts'], row['defects']]), axis=1)
df['defects'] = df['defects'].apply(remove_noncode_comments)
# создание словаря код дефекта - наименование дефекта
df_transl = pd.read_excel("def_transl.xlsx")
code_to_name = dict(zip(df_transl['code'], df_transl['col2']))
df['defect_codes'] = df['defects'].apply(extract_defect_codes)
df["defects_text_describtion"] = df["defects"].apply(lambda x: replace_defect_codes_with_description(x, df_transl))

